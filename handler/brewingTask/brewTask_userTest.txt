#include "./brewTask.h"
#include "../driver/data_format.h"
#include "../driver/grinder/grinder_driver.h"
#include "../driver/arranging/arranging_driver.h"
#include "../driver/heater/heater_driver.h"
#include "../driver/loadcell/loadcell_driver.h"
#include "../driver/pouring/pouringSection_driver.h"

// 린싱/분쇄/푸어링 상수들

extern QueueHandle_t gRecipeQueue;
extern QueueHandle_t gCommandQueue;
extern QueueHandle_t gSendQueue;
extern SharedState   gShared;

static constexpr uint32_t RINSE_PUMP_PWM      = 180;    // 린싱 펌프 세기
static constexpr uint32_t GRIND_MAX_MS        = 12000;  // 최대 분쇄 시간
static constexpr float    POUR_TARGET_EPSILON = 0.5f;   // 목표 수량 허용 오차(g)

// 현재 무게 읽기
static float readSharedWeight() {
    float w = 0.0f;
    if (xSemaphoreTake(gShared.mutex, portMAX_DELAY) == pdTRUE) {
        w = gShared.currentWeight;
        xSemaphoreGive(gShared.mutex);
    }
    return w;
}

static float readSharedTemp() {
    float t = 0.0f;
    if (xSemaphoreTake(gShared.mutex, portMAX_DELAY) == pdTRUE) {
        t = gShared.currentTemp;
        xSemaphoreGive(gShared.mutex);
    }
    return t;
}

static bool isTempStable() {
    bool s = false;
    if (xSemaphoreTake(gShared.mutex, portMAX_DELAY) == pdTRUE) {
        s = gShared.tempStable;
        xSemaphoreGive(gShared.mutex);
    }
    return s;
}

static void sendBrewStatus(DriverContext* driver, const char* status) {
    static StaticJsonDocument<128> doc;
    static sendItem item;
    doc["machine_id"] = driver->machine_id;
    doc["type"]      = "BREW_STATUS";
    doc["status"]    = status;

    JSON_TO_SENDITEM(item, doc);
    xQueueSendToBack(gSendQueue, &item, 0);
}

//========================= Step Functions =========================
// 린싱 + 원위치
void runRinse(DriverContext* driver, RecipeInfo& recipe) {
    Serial.println("[BREW] === RINSE ===");
    sendBrewStatus(driver, "RINSING");

    // 린싱을 위해 노즐 위치로 이동
    driver->grinder->setClicks(recipe.grind_level);
    driver->arranging->move(200);   // 실제 하드웨어에 맞게 조정
    // block 대신 간단한 대기 -> isMoving() 같은 함수 추가해서 개선해야함.
    vTaskDelay(1500 / portTICK_PERIOD_MS);

    // 린싱 -> 물 온도 도달 대기
    const float target = recipe.water_temperature_c - 2.0f;
    while (true) {
        // 개선 -> 린싱 중 중단 처리
        if (driver->status == BrewStatus::STOP) { stopAll(driver); return; }
        float t = readSharedTemp();
        if (t >= target) break;
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }

    driver->pouring->startPump(RINSE_PUMP_PWM);

    const uint32_t RINSE_PUMP_MS = 4000;
    uint32_t startMs = millis();
    while ((millis() - startMs) < RINSE_PUMP_MS) {
        if (driver->status == BrewStatus::STOP) { stopAll(driver); return; }
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
    driver->pouring->stopPump();
    driver->arranging->move(-200);
    vTaskDelay(1500 / portTICK_PERIOD_MS);
}

// 분쇄 
void runGrind(DriverContext* driver, RecipeInfo& recipe) {
    Serial.println("[BREW] === MAIN: GRIND + BREW ===");
    driver->grinder->startGrinding();
    while (driver->grinder->isGrinding()) {
        // 개선 -> 분쇄 중 중단 처리
        if (driver->status == BrewStatus::STOP) { stopAll(driver); return; }
        vTaskDelay(50 / portTICK_PERIOD_MS);
    }
    driver->arranging->move(200);    // 실제 하드웨어에 맞게 조정
    vTaskDelay(1500 / portTICK_PERIOD_MS);
}


// 푸어링 모드 결정
PouringTechnique stringToTechnique(const String& tech) {
    if (tech == "center") return PouringTechnique::CENTER;
    if (tech == "spiral_out") return PouringTechnique::SPIRAL_OUT;
    if (tech == "spiral_in") return PouringTechnique::SPIRAL_IN;
    if (tech == "pulse") return PouringTechnique::PULSE;
    if (tech == "circular") return PouringTechnique::CIRCULAR;
    return PouringTechnique::CENTER;  // 기본값
}

// 서버 이동 + 브루잉
void runBrew(DriverContext* driver, RecipeInfo& recipe) {
    Serial.println("[BREW] Pouring steps start");
    // 로드셀 영점 조정
    vTaskSuspend(driver->loadCellTaskHandle);
    driver->loadcell->tare(10);
    vTaskResume(driver->loadCellTaskHandle);
    sendBrewStatus(driver, "POURING");
    vTaskDelay(200 / portTICK_PERIOD_MS);
    float baseWeight = readSharedWeight();
    for (uint8_t i = 0; i < recipe.pouring_steps_count; ++i) {
        auto& step = recipe.pouring_steps[i];
        vTaskDelay(200 / portTICK_PERIOD_MS);

        // 펌프 ON (PWM 값 조정 필요)
        driver->pouring->startPump(200);
        driver->pouring->applyTechnique(stringToTechnique(step.technique));
        // 목표 수량까지 로드셀 모니터링
        while (true) {
            float w = readSharedWeight();
            float diff = w - baseWeight;
            if (diff >= step.water_g - POUR_TARGET_EPSILON) {
                break;
            }
            vTaskDelay(50 / portTICK_PERIOD_MS);
        }
        driver->pouring->stopPump();
        vTaskDelay(200 / portTICK_PERIOD_MS);
        baseWeight = readSharedWeight();
        // 각 스텝 사이 대기
        if (step.pour_time_s > 0) {
            vTaskDelay(step.pour_time_s * 1000 / portTICK_PERIOD_MS);
        }
    }
    Serial.println("[BREW] All pouring steps done");
    sendBrewStatus(driver, "DONE");
}



//========================= STOP ALL =========================
// 모든 기능 중지
void stopAll(DriverContext* driver) {
    driver->grinder->stopGrinding();
    driver->heater->stopHeating();
    driver->pouring->stopPump();

    // arranging 은 update 루프에서 멈춘 상태 유지
    setSendMode(SendMode::NONE);      // 모든 전송 중단
    xSemaphoreTake(gShared.mutex, portMAX_DELAY);
    gShared.currentTemp = 0.0f;
    gShared.tempStable = false;
    xSemaphoreGive(gShared.mutex);
    Serial.println("[BREW] STOP ALL");
    sendBrewStatus(driver, "STOPPED");
}


// ======================== Main Brew Task FSM =========================
// ===== 메인 Task.. =====
void BrewTask(void* pv) {
    DriverContext* driver = (DriverContext*)pv;
    RecipeInfo currentRecipe;
    static StaticJsonDocument<256> doc;
    static sendItem item;
    static cmdItem cmd;
    bool hasRecipe = false;

    while(true) {
        // 큐에서 레시피 갱신
        RecipeInfo next;
        if(xQueueReceive(gRecipeQueue, &next, 0) == pdTRUE){
            currentRecipe = next;
            hasRecipe = true;
            driver->recipe = currentRecipe;
            Serial.println("[BREW] Recipe loaded.");
        }
        // 커맨드 큐 처리
        if(xQueueReceive(gCommandQueue, &cmd, 0) == pdTRUE){
            String cmdStr(cmd.buf);
            if(cmdStr == "START_BREW") {
                if(hasRecipe) {
                    driver->status = BrewStatus::BREWSTART;
                    Serial.println("[BREW] START");
                }
            } 
            else if(cmdStr == "STOP_BREW") {
                driver->status = BrewStatus::STOP;
                Serial.println("[BREW] STOP");
            }
        }
        switch (driver->status) {
        case BrewStatus::IDLE:
            // 아무 것도 안 함
            setSendMode(SendMode::NONE);
            break;

        case BrewStatus::BREWSTART:
            // heater에 목표 온도 지시만 내림
            driver->heater->startHeating(currentRecipe.water_temperature_c);
            driver->status = BrewStatus::HEATING;
            sendBrewStatus(driver, "HEATING");
            setSendMode(SendMode::BREWING);
            break;

        case BrewStatus::HEATING:
            // gShared.tempStable만 참조 (mutex 보호)

            if (isTempStable()) {
                driver->status = BrewStatus::RINSING;
            }
            break;

        case BrewStatus::RINSING:
            setSendMode(SendMode::NONE);
            if (currentRecipe.rinsing) {
                runRinse(driver, currentRecipe); 
            }
            driver->status = BrewStatus::GRINDING;
            break;

        case BrewStatus::GRINDING:
            setSendMode(SendMode::NONE);
            runGrind(driver, currentRecipe);
            driver->status = BrewStatus::POURING;
            break;

        case BrewStatus::POURING:
            setSendMode(SendMode::BREWING);
            runBrew(driver, currentRecipe); 
            driver->status = BrewStatus::IDLE;
            stopAll(driver); 
            break;

        case BrewStatus::STOP:
            setSendMode(SendMode::NONE);
            stopAll(driver);
            doc.clear();
            driver->status = BrewStatus::IDLE;
            doc["machine_id"] = driver->machine_id;
            doc["type"] = "BREW_DONE";

            JSON_TO_SENDITEM(item, doc);
            xQueueSendToBack(gSendQueue, &item, 0);
            break;
        }
        vTaskDelay(50 / portTICK_PERIOD_MS);
    }
}